<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Stracture</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <h2>Data Stracture</h2>
    </header>
    <section>
        <article>
            <h3>course assingments:</h3>
            1. final exam - most of the final grade.
            2. 8 assingments if the sum of the assingments is 650 you get 5 points extra in the course 650/8=81.25
        </article>

        <article>
            <h2>Lacture One - Ran Ziv</h2>
            <pre>
                1. introduction: the importance of algorithm to for time complaxity,
                demenstrasions of plaing and analizing algorithms in sorting and merging using psaudo code,
                groth rate of functions, big O notation, theta and omega.
                regration equations: integrations and <mark>father methods?</mark>

                2. basic data structures: arrays, linked lists, stacks, queues, trees, graphs.



                note: the labs are in java.


                TEACHER NOTE: 1. never miss a chance to program.
                    

            </pre>

            <pre>
                1. we're looking to sum the numbers in an array:
                    <code >
                    // linear search:
                    int sum = 0;
                    for (int i = 0; i < arr.length; i++) {
                        sum += arr[i];
                    } // O(n)
                    </code>
                    
            </pre>

            <p>side notes: this is the first of a sires of courses</p>

            <p>the course is in hebrew</p>



        </article>



        <article>
            <h2>practice one - Elad Roda</h2>
            <pre>
                the main idea of this course is to becoume an efficient programmer
                whats is data stracture?
                data stracture is a way to organize data in a computer so that it can be used efficiently
                what is an algorithm?
                an algorithm is a set of steps to accomplish a task

                what is the data stracture that we will learn in this course?
                we will learn about:
                    arrays
                    linked lists 
                    stacks 
                    queues
                    trees
                    graphs
                    hash tables
                    heaps


                what will be the best data structure to find the maximum value in an array?
                the best data structure to find the maximum value in an array is the binary search tree

                what is an algorithm?
                a well defined set of steps to accomplish a task

                example for algorithm:
                    oclidean algorithm - to find the greatest common divisor of two numbers

                in this course we will get an problem and a number of steps to solve it and we will need to find the currect data strucure to solve it to achive the best time complexity




                efficiently on an algorithm - time complexity / space complexity    

                we are masuring the time complexity of an algorithm by the number of steps it takes to complete the task

                linear time complexity - O(n)


            </pre>

            <iframe width="560" height="315" src="https://www.youtube.com/embed/x6t1lKzjGhY"
                title="YouTube video player" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>
        </article>


<article>
    <h2> sorting algorithms </h2>
<pre>               
<b>insertion sort:</b>
    for i = 1 to n-1
        for j = i downto 1
            if a[j] < a[j-1]
                swap a[j] and a[j-1]
            else
                break


number of steps: n(n-1)/2 = n^2/2 - n/2                                    
time complexity: O(n^2) - quadratic time complexity
</pre>  
    
</article>


<article>
<pre>
<h2> Big O notation </h2>

let f(n) and g(n) 
monotonic and inclining functions
f(n) = O(g(n)) iff there is a positive constant c > 0 and a positive integer n0 such that f(n) <= c*g(n) for all n >= n0

proff: 

example:
    n/2 = O(n)
selotion:
    n/2 <= 1*n
    for each n >= 1
    choose: c = 1 and n0 = 1
    n = 0(n/2)
    n <= 3*n/2
    for each n >= 1
    choose: n0 = 1, c = 3



                     
    


3. sqrt(n^2 + 9*n) = O(n)
    selotions:
    sqrt(n^2 + 9*n) <= sqrt(n^2 + 9*n^2) = sqrt(10n^2) = 3*n
    for each n >= 1
    choose: c = 3 and n0 = 1


4. n^2 + 5n +12 = O(n^2)
    selotions:
        n^2 + 5n + 12 <= n^2 + 5n^2 + 12n^2 = 18n^2
        for each n >= 1
        choose: c = 18 and n0 = 1
    alt solution:
        n^2 + 5n + 12 <= c*n^2
        divide by n^2
        1 + 5/n + 12/n^2 <= c
        choose n = 10 and c = 2
        1 + 5/10 + 12/100 <= 2 -> true


5. 2*n^2 -7n + 2 = O(n^2)
    selotion:
    2*n^2 - 7n + 2 <= c*n^2
    divide by n^2
    2 - 7/n + 2/n^2 <= c
    choose: n = 2 -> then the inequality is true for all n > 1


6. n^2 = O(2^(n/2)) -> false
   proff by counter example:
      assome that n^2 = O(2^(n/2))
      then there is a positive constant c > 0 and a positive integer n0 such that n^2 <= c*2^(n/2) for all n >= n0
      if we divide by 2^(n/2) we get:
        n^2/2^(n/2) <= c
        2^(n/2) <= c
        contadtions for 2^(n/2) to be <= c:
        becouse c is a constant and 2^(n/2) is a monotinic and inclinig function of n

                    
                    
<h2>blocking by constant</h2>
using "omega" notation we can block by constant
f(n) = omega(g(n)) iff there is a positive constant c > 0 and a positive integer n0 such that f(n) >= c*g(n) for all n >= n0
                    

f(n) = for(int j = 1; j <= n; j++){j^3}
g(n) = n^4

a. prove f(n) = O(g(n))
b. prove f(n) = omega(g(n))

                
trick:
a. 
for(int j = 1; j <= n; j++){j^3} =  1^3 + 2^3 + 3^3 + ... + n^3 <= n^3 + n^3 + n^3 + ... + n^3 = n^3 * (1 + 1 + 1 + ... + 1) = n^3 * n = n^4
choose: n0 = 1, c=1

b.
for(int j=1; j<=n; j++){j^3} = 1^3 + 2^3 + 3^3 + ... + (n/2)^3 + (n/2 + 1)^3 + ... + n^3 >= (n/2)^3 + (n/2 + 1)^3 + ... + n^3 = n^3 * (1/2 + 1/2 + 1/2 + ... + 1/2) = (n/2)^3 * n/2 = (1/16)*n^4
choose: n0 = 1, c = 1/16
                    

in general:
for(int j = 1; j <= n; j++){j^k} = O(n^k+1)
for(int j = 1; j <= n; j++){j^k} = omega(n^k+1)


example:
let q > 1
f(n) = for(int i = 0; i < n; i++){q^i} = 1 + q + q^2 + ... + q^(n-1)

a. prove f(n) = O(q^n)
b. prove f(n) = omega(q^n)

b is easy: 
f(n) = 1 + q + q^2 + ... + q^(n-1) >= q^n 
choose: n0 = 1, c = q

a:
f(n) = 1 + q + q^2 + ... + q^(n-1) <= q^n + q^n + q^n + ... + q^n = q^n * (1 + 1 + 1 + ... + 1) = q^n * n = q^(n+1)

remember: sum(geomtric series Sn) = (a1*(q^n-1))/(q-1) = q^(n+1)/(q-1) = (q*q^n)/(q-1) = q/(q-1) * q^n
so: q/(q-1) is a constant -> c= q/(q-1), n0 = 1


remember: sum(numeric series Sn)= (a1 + an)*n/2 


remember:
logarithmic rolling: 
    1. log(a)(n^k) = k*log(a)(n)
    2. a^(log(a)(b)) = b
    3. log(a)(x) + log(a)(y) = log(a)(xy)
    4. log(a)(x/y) = log(a)(x) - log(a)(y)
    5. x^(log(a)(y)) = y^(log(a)(x))
    6. log(a)(x) = log(m)(x)/log(m)(a)


for now on we will use the following notation:
    log(n) = log(2)(n)

                    
prove: log(n)^log(n) = omega(n^(2/3))
proof:
    log(n)^log(n) >= (2^(2/3))^log(n) = (2^log(n))^(2/3) = n^(2/3)
    when log(n) >= log(2^2^(2/3))
    n >= 2^2^(2/3)
    n0 = 2^2^(2/3)  


            </pre>
        </article>

        <article>
            <h3>Class Excersize - Elad Roda</h3>
            <p class="code-space">
                int i,j,x;<br>
                for(i=1;i&lt;=n;i++)<br>
                &emsp;if(i%2==1)<br>
                &emsp;&emsp;for(j=i;j&lt;=n;j++)<br>
                &emsp;&emsp;&emsp;x=x+1;<br>
            </p>
            <p>
                T(n) = n + n-2 + n-4 + ... + 2 = n(n+1)/2 = O(n^2)
            </p>
            <p class="code-space">
                int func2(int n){<br>
                &emsp;int x, count;<br>
                &emsp;count = 0;<br>
                &emsp;x = 1;<br>
                &emsp;while(x&lt;n){<br>
                &emsp;&emsp;x = x*2;<br>
                &emsp;&emsp;count = count + 1;<br>
                &emsp;}<br>
                &emsp;return count;<br>
                }
           </p>
            <p>
                we can divide n by 2 until we get to 1, so we can say that n = 2^k, and k is the number of times we divided by 2.<br>
                so we can say that T(n) = k = O(log(n))
            </p>


            <p class="code-space">
                int func3(int n){<br>
                &emsp;int i, x;<br>
                &emsp;for(i = n; i >= 1; i--){<br>
                &emsp;x = 1;<br>
                &emsp;while(x&lt;i){<br>
                &emsp;&emsp;x *= 2;<br>
                &emsp;}<br>
                }

            </p>
        </article>
    </section>
</body>

</html>